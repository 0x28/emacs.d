#+TITLE: emacs settings
* package setup
  Bootstraps use-package and sets the repositories.
  #+BEGIN_SRC emacs-lisp :results silent
    ;; set up package sources
    (require 'package)
    (require 'nsm)

    (setq network-security-level 'high)
    (setq gnutls-min-prime-bits 2048)
    (setq gnutls-verify-error t)

    (setq package-archives
          '(("gnu" . "https://elpa.gnu.org/packages/")
            ("melpa" . "https://melpa.org/packages/")
            ("gnu-mirror" . "https://gitlab.com/0x28/elpa-mirror/raw/master/gnu/")
            ("melpa-mirror" . "https://gitlab.com/0x28/elpa-mirror/raw/master/melpa/")))

    (setq package-archive-priorities
          '(("gnu" . 20)
            ("melpa" . 20)
            ("gnu-mirror" . 0)
            ("melpa-mirror" . 0)))

    (setq package-enable-at-startup nil)
    (package-initialize)

    ;; bootstrap `use-package'
    (unless (package-installed-p 'use-package)
      (package-refresh-contents)
      (package-install 'use-package))
  #+END_SRC

* evil
  Vim emulation for emacs.
  #+BEGIN_SRC emacs-lisp :results silent
    (use-package evil
      :ensure t
      :demand
      :init
      (setq evil-want-keybinding nil)
      :bind*
      (:map evil-normal-state-map
            ("SPC f i" . my/edit-init-file)
            ("SPC f s" . my/ssh-connect)
            ("SPC q n" . save-buffers-kill-emacs)
            ("SPC n d" . narrow-to-defun)
            ("SPC n w" . widen))
      (:map evil-visual-state-map
            ("SPC n r" . narrow-to-region))
      :config
      (define-key evil-normal-state-map (kbd "M-.") nil)
      (evil-define-key 'normal org-mode-map (kbd "<tab>") #'org-cycle)
      (evil-define-key 'normal org-mode-map (kbd "TAB") #'org-cycle)

      (setq evil-normal-state-tag
            (propertize " N " 'face '((:foreground "green")))
            evil-emacs-state-tag
            (propertize " E " 'face '((:foreground "orange")))
            evil-insert-state-tag
            (propertize " I " 'face '((:foreground "red")))
            evil-motion-state-tag
            (propertize " M " 'face '((:foreground "deep sky blue")))
            evil-visual-state-tag
            (propertize " V " 'face '((:foreground "grey80")))
            evil-replace-state-tag
            (propertize " R " 'face '((:foreground "yellow")))
            evil-operator-state-tag
            (propertize " O " 'face '((:foreground "purple"))))

      (setq evil-lookup-func (lambda () (interactive)
                               (call-interactively #'man)))
      (evil-mode))
  #+END_SRC

* evil collection
  #+BEGIN_SRC emacs-lisp :results silent
    (use-package evil-collection
      :ensure t
      :config
      (setq evil-collection-key-blacklist (list "SPC"))
      (setq evil-collection-company-use-tng nil)
      (evil-collection-init))
  #+END_SRC

* evil multiple cursors
  #+BEGIN_SRC emacs-lisp :results silent
    (defun my/evil-mc-dispatch ()
      "Dispatch command to create multiple cursors."
      (interactive)
      (set-transient-map
       (let ((map (make-sparse-keymap)))
         (define-key map (kbd "C-n") #'evil-mc-make-and-goto-next-match)
         (define-key map (kbd "C-p") #'evil-mc-make-and-goto-prev-match)
         (define-key map (kbd "C-a") #'evil-mc-make-all-cursors)
         (message "%s" (substitute-command-keys "\\{map}"))
         map)
       t))

    (defun my/evil-mc-lines ()
      "Create cursors for each line of the active selection."
      (interactive)
      (evil-mc-make-cursor-in-visual-selection-beg)
      (evil-normal-state))

    (evil-define-key 'normal 'global (kbd "SPC m") #'my/evil-mc-dispatch)
    (evil-define-key 'visual 'global (kbd "SPC m") #'my/evil-mc-lines)

    (use-package evil-mc
      :ensure t
      :commands (evil-mc-make-and-goto-next-match
                 evil-mc-make-and-goto-prev-match
                 evil-mc-make-all-cursors
                 evil-mc-make-cursor-in-visual-selection-beg)
      :config
      (setq evil-mc-undo-cursors-on-keyboard-quit t
            evil-mc-custom-known-commands
            '((newline                 (:insert . evil-mc-execute-call))
              (c-indent-line-or-region (:insert . evil-mc-execute-call))
              (upcase-word             (:default . evil-mc-execute-default-call-with-count))
              (downcase-word           (:default . evil-mc-execute-default-call-with-count))))
      (global-evil-mc-mode 1))
  #+END_SRC

* undo-tree
  #+BEGIN_SRC emacs-lisp :results silent
    (use-package undo-tree
      :ensure t
      :config
      (setq undo-tree-visualizer-timestamps t
            undo-tree-visualizer-relative-timestamps t)

      (defun my/undo-tree-config ()
        (setq undo-tree-visualizer-diff t))
      :hook (undo-tree-visualizer-mode . my/undo-tree-config))
  #+END_SRC

* company
  Generic settings for the completion framework company.
  #+BEGIN_SRC emacs-lisp :results silent
    (use-package company
      :ensure t
      :config
      (add-hook 'after-init-hook #'global-company-mode)

      (define-key company-active-map (kbd "<tab>") #'company-complete-common-or-cycle)
      (define-key company-active-map (kbd "TAB") #'company-complete-common-or-cycle)

      (setq company-selection-wrap-around t
            company-idle-delay 0.1
            company-minimum-prefix-length 1))
  #+END_SRC

* ivy
  #+BEGIN_SRC emacs-lisp :results silent
    (use-package ivy
      :ensure t
      :defer t
      :bind* (("C-x b" . ivy-switch-buffer))
      :config
      (setq ivy-height 20
            ivy-re-builders-alist '((t . ivy--regex-ignore-order))
            ivy-use-virtual-buffers t
            ivy-virtual-abbreviate 'abbreviate)
      (ivy-mode))

    (use-package swiper
      :ensure t
      :bind* (("C-c f" . swiper)))

    (use-package counsel
      :ensure t
      :bind* (("M-x" . counsel-M-x)
              ("C-x C-f" . counsel-find-file)
              ("C-h f" . counsel-describe-function)
              ("C-h v" . counsel-describe-variable)
              ("C-h b" . counsel-descbinds)
              ("C-c d" . counsel-imenu)
              ("C-c r" . counsel-recentf)
              ("C-c k" . counsel-yank-pop))
      (:map evil-normal-state-map
            ("SPC SPC" . counsel-M-x)
            ("SPC f f" . counsel-find-file)
            ("SPC f r" . counsel-recentf)
            ("SPC f l" . counsel-locate))
      :config
      (setq counsel-find-file-at-point t)
      (setf (cdr (assoc 'counsel-M-x ivy-initial-inputs-alist)) "")
      (setq counsel-async-filter-update-time 100000) ;; every 0.1 seconds
      (counsel-mode))
  #+END_SRC

* dired
  #+BEGIN_SRC emacs-lisp :results silent
    (use-package dired-x
      :bind*
      (:map evil-normal-state-map
            ("SPC f d" . dired-jump-other-window))
      (:map dired-mode-map
            ("<tab>" . dired-omit-mode)
            ("<backtab>" . dired-hide-details-mode))
      :hook (dired-mode . dired-omit-mode)
      :hook (dired-mode . dired-hide-details-mode)
      :config
      (setq dired-auto-revert-buffer t)
      (setq dired-dwim-target t)
      (setq dired-omit-files "^\\.?#\\|^\\.[^.\n].*$")
      (evil-define-key 'normal dired-mode-map (kbd "C-o") #'dired-display-file))
  #+END_SRC

* occur
  The function occur is defined within replace.el but it is missing a provide
  statement in emacs 25. Therefore the config has to be inside an init block.
  #+BEGIN_SRC emacs-lisp :results silent
    (use-package replace
      :hook (occur-mode . next-error-follow-minor-mode)
      :init
      (setq list-matching-lines-default-context-lines 3))
  #+END_SRC

* which key
  #+BEGIN_SRC emacs-lisp :results silent
    ;; show keybindings while typing
    (use-package which-key
      :ensure t
      :defer 1
      :config
      (which-key-mode)
      (setq which-key-idle-delay 0.5)
      (which-key-add-key-based-replacements
        "SPC b" "bookmarks"
        "SPC f" "files"
        "SPC g" "git"
        "SPC h" "help"
        "SPC n" "narrow"
        "SPC p" "project"
        "SPC q" "quit"
        "SPC v" "version control"))
  #+END_SRC

* flycheck/flymake
  #+BEGIN_SRC emacs-lisp :results silent
    (defun my/list-errors ()
      "Use flycheck or flymake to list errors."
      (interactive)
      (cond ((bound-and-true-p flycheck-mode) (flycheck-list-errors))
            ((bound-and-true-p flymake-mode) (flymake-show-diagnostics-buffer))
            (t (user-error "Neither flycheck nor flymake are enabled"))))

    (define-key evil-normal-state-map (kbd "SPC e l") #'my/list-errors)

    (use-package flycheck
      :ensure t
      :defer t
      :hook (prog-mode . flycheck-mode))
  #+END_SRC

* yasnippet
  #+BEGIN_SRC emacs-lisp :results silent
    ;; snippet completion
    (use-package yasnippet
      :ensure t
      :bind* ("C-c y" . yas-insert-snippet)
      :hook (prog-mode . yas-minor-mode)
      :config
      (dolist (key (list "TAB" "<tab>"))
        (define-key yas-minor-mode-map (kbd key) nil)))
  #+END_SRC
  Also load the snippets.
  #+BEGIN_SRC emacs-lisp :results silent
    (use-package yasnippet-snippets
      :ensure t
      :after yasnippet)
  #+END_SRC

* theme
  #+BEGIN_SRC emacs-lisp :results silent
    (use-package doom-themes
      :ensure t
      :config
      (if (daemonp)
          (add-hook 'after-make-frame-functions
                    (lambda (frame)
                      (with-selected-frame frame
                        (unless (member 'doom-dracula custom-enabled-themes)
                          (load-theme 'doom-dracula t)))))
        (load-theme 'doom-dracula t))

      (add-hook 'org-mode-hook
                (lambda ()
                  (dolist (face '(org-level-1
                                  org-level-2
                                  org-level-3
                                  org-level-4
                                  org-level-5))
                    (set-face-attribute face
                                        nil
                                        :weight 'semi-bold
                                        :height 1.0)))))
  #+END_SRC

* eshell
  #+BEGIN_SRC emacs-lisp :results silent
    (use-package eshell
      :ensure t
      :bind* (("C-c s" . my/toggle-eshell))
      :hook
      (eshell-mode . (lambda ()
                       (local-set-key (kbd "C-r") #'counsel-esh-history)
                       (local-set-key (kbd "TAB") #'company-complete-common)
                       (local-set-key (kbd "<tab>") #'company-complete-common)
                       (setq-local global-hl-line-mode nil)
                       (setq-local company-idle-delay nil)
                       (setq-local company-backends (list #'company-capf))))
      :config
      (evil-set-initial-state 'eshell-mode 'emacs)
      (setq eshell-cmpl-ignore-case t
            eshell-error-if-no-glob t
            eshell-hist-ignoredups t
            eshell-scroll-to-bottom-on-input t
            eshell-cmpl-cycle-completions nil)
      :custom-face
      (eshell-prompt ((t (:inherit minibuffer-prompt :weight normal)))))

    (defun my/toggle-eshell ()
      "Open a new eshell window or switch to an existing one."
      (interactive)
      (let* ((eshell-window (get-buffer-window "*eshell*"))
             (current-directory default-directory)
             (cd-to-default-dir (lambda ()
                                  (unless (string= default-directory
                                                   current-directory)
                                    (eshell/cd current-directory)
                                    (eshell-reset)))))
        (cond ((eq (selected-window) eshell-window)
               (delete-window))
              ((window-live-p eshell-window)
               (select-window eshell-window)
               (funcall cd-to-default-dir))
              (t
               (select-window
                (split-window (frame-root-window)
                              (/ (frame-height) -3)
                              'below))
               (eshell)
               (funcall cd-to-default-dir)))))
  #+END_SRC

* whitespace
  #+BEGIN_SRC emacs-lisp :results silent
    (use-package whitespace
      :ensure t
      :hook ((prog-mode . whitespace-mode)
             (diff-mode . whitespace-mode))
      :config
      (setq-default
       fill-column 80
       whitespace-line-column fill-column
       whitespace-style '(face trailing lines-tail)))
  #+END_SRC

* line numbers
  #+BEGIN_SRC emacs-lisp :results silent
    (use-package display-line-numbers
      :if (fboundp 'display-line-numbers-mode)
      :hook (prog-mode . display-line-numbers-mode))
  #+END_SRC

* C, C++
  #+BEGIN_SRC emacs-lisp :results silent
    (defalias 'cxx-mode #'c++-mode)

    (use-package clang-format
      :ensure t
      :defer t)

    (defun my/c-and-c++-config ()
      "Setup C and C++ config."
      (setq-local company-backends '((company-files
                                      company-capf
                                      company-yasnippet
                                      company-keywords))))

    (use-package cc-mode
      :bind* (:map c-mode-map
                   ("C-c i" . clang-format-buffer))
      :bind* (:map c++-mode-map
                   ("C-c i" . clang-format-buffer))
      :hook
      (((c-mode c++-mode) . my/c-and-c++-config))
      :config
      (defconst my-cc-style
        '((c-basic-offset . 4)
          (c-comment-only-line-offset . 0)
          (c-offsets-alist
           (innamespace . 0)
           (case-label . +)
           (statement-block-intro . +)
           (knr-argdecl-intro . +)
           (substatement-open . 0)
           (substatement-label . 0)
           (label . 0)
           (statement-cont . +)
           (inline-open . 0)
           (inexpr-class . 0))))

      (c-add-style "my-style" my-cc-style)
      (setq-default c-default-style "my-style"))
  #+END_SRC

* lsp
  #+BEGIN_SRC emacs-lisp :results silent
    (use-package lsp-mode
      :ensure t
      :defer)

    (use-package company-lsp
      :ensure t
      :defer t)
  #+END_SRC

* Rust
  #+BEGIN_SRC emacs-lisp :results silent
    (use-package rust-mode
      :ensure t
      :bind* (:map rust-mode-map
                   ("C-c i" . rust-format-buffer))
      :hook (rust-mode . lsp)
      :hook (rust-mode . (lambda () (flycheck-mode -1)))
      :config
      (setq lsp-rust-all-features t))
  #+END_SRC

* CMake
  #+BEGIN_SRC emacs-lisp :results silent
    (use-package cmake-mode
      :ensure t
      :config
      (setq cmake-tab-width 4))
  #+END_SRC

* compile
  #+BEGIN_SRC emacs-lisp :results silent
    (use-package compile
      :defer t
      :bind* (:map compilation-mode-map
                   ("SPC" . nil))
      :config
      (setq compilation-scroll-output 'first-error))
  #+END_SRC

* align
  #+BEGIN_SRC emacs-lisp :results silent
    (defun my/align-whitespace (begin end)
      "Align columns by whitespace between BEGIN and END."
      (interactive "r")
      (align-regexp begin end
                    "\\(\\s-*\\)\\s-" 1 0 t))

    (use-package align
        :bind* (:map evil-visual-state-map
                     ("SPC a a" . align)
                     ("SPC a r" . align-regexp)
                     ("SPC a w" . my/align-whitespace)))
  #+END_SRC

* version control
  Settings for the builtin vc.el.
  #+BEGIN_SRC emacs-lisp :results silent
    (define-key evil-normal-state-map (kbd "SPC v") #'vc-prefix-map)
    (setq vc-follow-symlinks t)
  #+END_SRC
  Magit keybindings.
  #+BEGIN_SRC emacs-lisp :results silent
    (use-package magit
      :ensure t
      :bind* (:map evil-normal-state-map
                   ("SPC g s" . magit-status)
                   ("SPC g g" . magit-dispatch)
                   ("SPC g l" . magit-log-current)))

    (use-package evil-magit
      :ensure t
      :after magit)
  #+END_SRC

* recentf
  #+BEGIN_SRC emacs-lisp :results silent
    (use-package recentf
      :config
      (recentf-mode 1)
      (run-with-idle-timer (* 60 2) t #'recentf-save-list)
      ;; save more recent files
      (setq recentf-max-saved-items 100))
  #+END_SRC

* LaTeX
  #+BEGIN_SRC emacs-lisp :results silent
    (use-package tex-site
      :ensure auctex
      :hook (LaTeX-mode . TeX-source-correlate-mode)
      :defer t
      :config
      (setq font-latex-fontify-sectioning 1.0)
      (setq-default TeX-view-program-selection
                    (quote (((output-dvi has-no-display-manager) "dvi2tty")
                            ((output-dvi style-pstricks) "dvips and gv")
                            (output-dvi "xdvi")
                            (output-pdf "Okular")
                            (output-html "xdg-open")))))
  #+END_SRC

* bookmarks
  Some bookmark keybindings.
  #+BEGIN_SRC emacs-lisp :results silent
    (use-package bookmark
      :ensure t
      :bind* (:map evil-normal-state-map
                   ("SPC b l" . list-bookmarks)
                   ("SPC b s" . bookmark-set)
                   ("SPC b j" . bookmark-jump)))
  #+END_SRC

* projectile
  #+BEGIN_SRC emacs-lisp :results silent
    (defun my/project-rg ()
      "Search with ripgrep within project."
      (interactive)
      (counsel-rg (thing-at-point 'symbol t)
                  (projectile-project-root)))

    (use-package projectile
      :ensure t
      :defer t
      :init
      ;; define "SPC p" as additional prefix for projectile
      (define-key evil-normal-state-map (kbd "SPC p") #'projectile-command-map)
      (autoload #'projectile-command-map "projectile" nil t 'keymap)
      :config
      (projectile-mode)
      (setq projectile-completion-system 'default)
      (setq projectile-enable-caching t)

      (push "CMakeLists.txt" projectile-project-root-files-top-down-recurring)

      (define-key projectile-command-map (kbd "s") #'my/project-rg)

      ;; compatibility layer between projectile and project.el
      (defun my/projectile-project-find-function (dir)
        (let ((root (projectile-project-root dir)))
          (and root (cons 'transient root))))

      (require 'project)
      (add-to-list 'project-find-functions #'my/projectile-project-find-function))
  #+END_SRC

* quickrun
  #+BEGIN_SRC emacs-lisp :results silent
    (use-package quickrun
      :ensure t
      :bind* (("C-c x" . quickrun)))
  #+END_SRC

* dash
  #+BEGIN_SRC emacs-lisp :results silent
    (use-package counsel-dash
      :ensure t
      :init
      (defun my/view-docs-for-major-mode ()
        "Read the documentation for the programming language of the
    current major-mode. Use `counsel-dash-install-docset' or Zeal to
    download docsets."
        (interactive)
        (setq-local counsel-dash-docsets
                    (cdr (assoc major-mode '((sh-mode     . ("Bash"))
                                             (rust-mode   . ("Rust"))
                                             (c-mode      . ("C"))
                                             (c++-mode    . ("C++" "Boost"))
                                             (lisp-mode   . ("Common_Lisp"))
                                             (cmake-mode  . ("CMake"))
                                             (latex-mode  . ("LaTeX"))
                                             (tex-mode    . ("LaTeX"))
                                             (python-mode . ("Python_3"))))))
        (if counsel-dash-docsets
            (counsel-dash (thing-at-point 'symbol t))
          (message "no docsets found for %s" major-mode)))
      :bind* (:map evil-normal-state-map
                   ("SPC h d" . my/view-docs-for-major-mode)))
  #+END_SRC

* smex
  Counsel-M-x doesn't provide a command history. But it uses smex when
  available.
  #+BEGIN_SRC emacs-lisp :results silent
    (use-package smex
      :ensure t
      :after counsel)
  #+END_SRC

* ibuffer
  #+BEGIN_SRC emacs-lisp :results silent
    (use-package ibuffer
      :bind ("C-x C-b" . ibuffer-other-window))
  #+END_SRC

* additional keywords
  Some words like "FIXME" and "TODO" should be highlighted in every programming
  mode. It doesn't matter if they're inside comments or not.
  #+BEGIN_SRC emacs-lisp :results silent
    (defun my/add-new-keywords()
      (font-lock-add-keywords
       nil
       '(("\\<\\(FIXME\\|fixme\\)\\>" 1 'font-lock-warning-face prepend)
         ("\\<\\(TODO\\|todo\\)\\>" 1 'font-lock-warning-face prepend)
         ("\\<\\(BUG\\|bug\\)\\>" 1 'font-lock-warning-face prepend)
         ("\\<\\(NOTE\\|note\\)\\>" 1 'font-lock-constant-face prepend))))

    (add-hook 'prog-mode-hook #'my/add-new-keywords)
  #+END_SRC

* sane defaults
** visual
  #+BEGIN_SRC emacs-lisp :results silent
    ;; don't show a startup message
    (setq inhibit-startup-message t)
    ;; no menu-bar
    (menu-bar-mode -1)
    ;; no blinking cursor
    (blink-cursor-mode -1)
    ;; highlight the current line
    (global-hl-line-mode)
    ;; column numbers
    (column-number-mode 1)
    ;; show matching parentheses
    (show-paren-mode)
    ;; start emacs maximized
    (add-to-list 'default-frame-alist '(fullscreen . maximized))
    ;; use hack or consolas font
    (add-to-list 'default-frame-alist
                 (cons 'font
                       (cond ((eq system-type 'gnu/linux) "Hack-13")
                             ((eq system-type 'windows-nt) "Consolas-14"))))
    ;; pretty lambdas
    (global-prettify-symbols-mode t)
    (setq prettify-symbols-unprettify-at-point 'right-edge)
    ;; smoother scrolling
    (setq scroll-conservatively most-positive-fixnum)
    ;; resize windows proportionally
    (setq window-combination-resize t)
    ;; hide minor-modes in mode-line
    (setq mode-line-modes '(:eval (propertize " [%m] "
                                              'face 'font-lock-constant-face)))
  #+END_SRC

** convenience
  #+BEGIN_SRC emacs-lisp :results silent
    ;; save backups in .emacs.d
    (setq backup-directory-alist '(("." . "~/.emacs.d/.backups")))
    ;; save auto-save files (#file#) in .emacs.d
    (let ((auto-save-dir "~/.emacs.d/.autosaves/"))
      (make-directory auto-save-dir t)
      (setq auto-save-file-name-transforms `((".*" ,auto-save-dir t))))
    ;; no tabs
    (setq-default indent-tabs-mode nil)
    ;; update files when they change on disk
    (global-auto-revert-mode 1)
    ;; ask before killing emacs
    (setq confirm-kill-emacs #'y-or-n-p)
    ;; automatically go to the help window
    (setq help-window-select t)
    ;; sentences have a single space at the end
    (setq sentence-end-double-space nil)
    ;; typed text replaces the selected text
    (delete-selection-mode 1)
    ;; don't accelerate mouse wheel scrolling
    (setq mouse-wheel-progressive-speed nil)
    ;; show off-screen matching parens when typing
    (setq blink-matching-paren 'echo)
    ;; add matching pairs automatically
    (electric-pair-mode 1)
    ;; make *scratch* unkillable
    (with-current-buffer "*scratch*"
      (emacs-lock-mode 'kill))
    ;; reduce the delay for creating frames and for using undo-tree
    (when (eq system-type 'gnu/linux)
      (setq x-wait-for-event-timeout nil))
    ;; ask "(y/n)?" and not "(yes/no)?"
    (fset #'yes-or-no-p #'y-or-n-p)
    ;; more information on describe-key
    (define-key (current-global-map) (kbd "C-h c") #'describe-key)
  #+END_SRC

* custom functions
  Small functions used in the keybindings.
** edit init file
   Function used to quickly edit my settings.org file.
  #+BEGIN_SRC emacs-lisp :results silent
    (defun my/edit-init-file ()
      "Open the init file."
      (interactive)
      (find-file (expand-file-name "settings.org" user-emacs-directory)))
  #+END_SRC

** indent buffer
   This function removes trailing whitespace, indents the current buffer and
   removes tabs. For Makefiles it only removes trailing whitespace.
  #+BEGIN_SRC emacs-lisp :results silent
    (defun my/indent-buffer ()
      "Indent and untabify the current buffer."
      (interactive)
      (save-excursion
        (delete-trailing-whitespace)
        (unless (derived-mode-p 'makefile-mode)
          (indent-region (point-min) (point-max) nil)
          (untabify (point-min) (point-max)))))

    (global-set-key (kbd "C-c i") #'my/indent-buffer)
  #+END_SRC

** toggle maximize buffer
   This function maximizes the current buffer, hiding the other buffers inside
   the current frame. A further call restores the old buffer layout.
  #+BEGIN_SRC emacs-lisp :results silent
    ;; from https://gist.github.com/3402786
    (defun my/toggle-maximize-buffer ()
      "Maximize buffer"
      (interactive)
      (if (and (= 1 (length (window-list)))
               (assoc ?_ register-alist))
          (jump-to-register ?_)
        (progn
          (window-configuration-to-register ?_)
          (delete-other-windows))))

    (global-set-key (kbd "C-x 1") #'my/toggle-maximize-buffer)
  #+END_SRC

** ssh connect
   Use tramp to connect to a host in the local network. Uses the ip command to
   find possible hosts.
  #+BEGIN_SRC emacs-lisp :results silent
    (defun my/local-hosts ()
      "Return a list of hosts in the local network."
      (split-string
       (shell-command-to-string
        "ip neigh show nud stale nud reachable | cut -d ' ' -f 1")))

    (defun my/ssh-connect ()
      "Connect to the home directory of a foreign host."
      (interactive)
      (let ((host (completing-read "host: " (my/local-hosts)))
            (user (read-string "user: ")))
        (message "connecting to %s@%s ..." user host)
        (find-file (concat "/ssh:" user "@" host ":~"))))

  #+END_SRC

** duckduckgo dwim
  #+BEGIN_SRC emacs-lisp :results silent
    (defun my/ddg-dwim ()
      "Search duckduckgo.com for the symbol at point or the region if active."
      (interactive)
      (let* ((symbol (or (thing-at-point 'symbol t) ""))
             (user-input
              (if (region-active-p)
                  (buffer-substring-no-properties (region-beginning)
                                                  (region-end))
                (read-string (format "search term [default: \"%s\"]: " symbol)
                             nil
                             'ddg-input-history
                             symbol))))
        (thread-last user-input
          url-hexify-string
          (concat "https://duckduckgo.com/?q=")
          browse-url)))

    (global-set-key (kbd "C-c g") #'my/ddg-dwim)
  #+END_SRC

** kill current buffer
   Kill the current buffer without asking.
  #+BEGIN_SRC emacs-lisp :results silent
    (defun my/kill-current-buffer ()
      "Kill the current buffer."
      (interactive)
      (kill-buffer (current-buffer)))

    (global-set-key (kbd "C-x k") #'my/kill-current-buffer)
  #+END_SRC

** yank words to minibuffer
  #+BEGIN_SRC emacs-lisp :results silent
    (defun my/minibuffer-yank-word (&optional arg)
      "Yank ARG words from current line into minibuffer."
      (interactive "p")
      (let (text)
        (with-current-buffer (cadr (buffer-list))
          (let* ((beg (point))
                 (bol (line-beginning-position))
                 (eol (line-end-position))
                 (end (progn (forward-word arg)
                             (goto-char (max bol (min (point) eol))))))
            (setq text (buffer-substring-no-properties beg end))
            (pulse-momentary-highlight-region beg end 'region)))
        (when text
          (insert (replace-regexp-in-string "  +" " " text t t)))))

    (define-key minibuffer-local-map (kbd "M-j") #'my/minibuffer-yank-word)
  #+END_SRC

** confirm closing emacsclient frames
  #+BEGIN_SRC emacs-lisp :results silent
     (defun my/confirm-kill-terminal (&optional arg)
       "Ask for confirmation when closing frames.
     With prefix ARG, silently save all file-visiting buffers, then kill."
       (interactive "P")
       (when (y-or-n-p "Close frame? ")
         (save-buffers-kill-terminal arg)))

     (when (daemonp)
       (global-set-key [remap save-buffers-kill-terminal] #'my/confirm-kill-terminal))
  #+END_SRC

